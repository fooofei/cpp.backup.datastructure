/* 
** 目前最快的N皇后递归解决方法 
** N Queens Problem 
** 试探-回溯算法，递归实现 
*/  
#include <iostream>  
using namespace std;  
#include <time.h> 

// sum用来记录皇后放置成功的不同布局数；upperlim用来标记所有列都已经放置好了皇后。  
long sum = 0, upperlim = 1;       

// 试探算法从最右边的列开始。  
void test(long row, long ld, long rd)  
{  
	if (row != upperlim)  
	{  
		// row，ld，rd进行“或”运算，求得所有可以放置皇后的列,对应位为0，  
		// 然后再取反后“与”上全1的数，来求得当前所有可以放置皇后的位置，对应列改为1  
		// 也就是求取当前哪些列可以放置皇后  
		long pos = upperlim & ~(row | ld | rd);   
		while (pos)    // 0 -- 皇后没有地方可放，回溯  
		{  
			// 拷贝pos最右边为1的bit，其余bit置0  
			// 也就是取得可以放皇后的最右边的列  
			long p = pos & -pos;                                                

			// 将pos最右边为1的bit清零  
			// 也就是为获取下一次的最右可用列使用做准备，  
			// 程序将来会回溯到这个位置继续试探  
			pos -= p;                             

			// row + p，将当前列置1，表示记录这次皇后放置的列。  
			// (ld + p) << 1，标记当前皇后左边相邻的列不允许下一个皇后放置。  
			// (ld + p) >> 1，标记当前皇后右边相邻的列不允许下一个皇后放置。  
			// 此处的移位操作实际上是记录对角线上的限制，只是因为问题都化归  
			// 到一行网格上来解决，所以表示为列的限制就可以了。显然，随着移位  
			// 在每次选择列之前进行，原来N×N网格中某个已放置的皇后针对其对角线  
			// 上产生的限制都被记录下来了  
			test(row + p, (ld + p) << 1, (rd + p) >> 1);                                
		}  
	}  
	else     
	{  
		// row的所有位都为1，即找到了一个成功的布局，回溯  种数自加
		sum++;  
	}  
}  

int main(int argc, char *argv[])  
{  
	time_t tm;  
	int n = 10;  
	printf("输入皇后规模\n");
	scanf("%d",&n);
	tm = time(0);  

	// 因为整型数的限制，最大只能31位，  
	// 如果想处理N大于31皇后问题，需要  
	// 用bitset数据结构进行存储  
	if ((n < 1) || (n >= 32))                   
	{  
		printf(" 只能计算1-32之间\n");  
		exit(-1);  
	}  
	printf("%d 皇后\n", n);  

	// N个皇后只需N位存储，N列中某列有皇后则对应bit置1。  
	upperlim = (upperlim << n) - 1;           

	test(0, 0, 0);  
	printf("共有%ld种排列, 计算时间%d秒 \n", sum, (int) (time(0) - tm));  
	system("pause");  
	return 0;  
}

// Debug 版本
// 16 皇后
// 共有14772512种排列, 计算时间35秒

// Release 版本
// 16 皇后
// 共有14772512种排列, 计算时间14秒

// upperlime：=（1 << n）-1 就生成了n个1组成的二进制数。
// 这个程序是从上向下搜索的。
// pos& -pos 的意思就是取最右边的 1 再组成二进制数，相当于pos &（~pos +1），因为取反以后刚好所有数都是相反的（怎么听着像废话），
// 再加 1 ，就是改变最低位，如果低位的几个数都是1，加的这个 1 就会进上去，一直进到 0 ，在做与运算就和原数对应的 1 重合了。举例可以说明：
// 原数      0 0 0 0 1 0 0 0       原数 0 1 0 1 0 0 1 1
// 取反      1 1 1 1 0 1 1 1       取反 1 0 1 0 1 1 0 0
// 加 1      1 1 1 1 1 0 0 0        加1 1 0 1 0 1 1 0 1
// 与运算    0 0 0 0 1 0 0 0        &   0 0 0 0 0 0 0 1
// 其中呢，这个取反再加 1 就是补码，and 运算 与负数，就是按位和补码与运算。


// (ld | p)<< 1 是因为由ld造成的占位在下一行要右移一下；
// (rd | p)>> 1 是因为由rd造成的占位在下一行要左移一下。
// ld rd row 还要和upperlime与运算 一下，这样做的结果就是从最低位数起取n个数为有效位置，原因是在上一次的运算中ld发生了右移，
// 如果不and的话，就会误把n以外的位置当做有效位。
// pos 已经完成任务了还要减去p 是因为？
// while 循环是因为？
// 在进行到某一层的搜索时，pos中存储了所有的可放位置，为了求出所有解，必须遍历所有可放的位置，而每走过一个点必须要删掉它，否则就成死循环啦！
// 这个是目前公认N皇后的最高效算法。
// 程序采用了递归，也就是借用了编译系统提供的自动回溯功能。
// 算法的核心：使用bit数组来代替以前由int或者bool数组来存储当前格子被占用或者说可用信息，从这可以看出N个皇后对应需要N位表示。
// 巧妙之处在于：以前我们需要在一个N*N正方形的网格中挪动皇后来进行试探回溯，每走一步都要观察和记录一个格子前后左右对角线上格子的信息；采用bit位进行信息存储的话，就可以只在一行格子也就是（1行×N列）个格子中进行试探回溯即可，对角线上的限制被化归为列上的限制。
// 程序中主要需要下面三个bit数组，每位对应网格的一列，在C中就是取一个整形数的某部分连续位即可。row用来记录当前哪些列上的位置不可用，也就是哪些列被皇后占用，对应为1。ld，rd同样也是记录当前哪些列位置不可用，但是不表示被皇后占用，而是表示会被已有皇后在对角线上吃掉的位置。这三个位数组进行“或”操作后就是表示当前还有哪些位置可以放置新的皇后，对应0的位置可放新的皇后。如下图所示的8皇后问题求解得第一步：
// row: [ ][ ][ ][ ][ ][ ][ ][*]
// ld: [ ][ ][ ][ ][ ][ ][*][ ]
// rd: [ ][ ][ ][ ][ ][ ][ ][ ]
// --------------------------------------
// row|ld|rd: [ ][ ][ ][ ][ ][ ][*][*]
// 所有下一个位置的试探过程都是通过位操作来实现的，这是借用了C语言的好处，详见代码注释。
// 关于此算法，如果考虑N×N棋盘的对称性，对于大N来说仍能较大地提升效率！
// 位操作－－对优化算法有了个新的认识
  // 　　这个是在csdn找到的一个N皇后问题最快的算法，看了好一会才明白，这算法巧妙之处我认为有２个：
  //   １、以前都是用数组来描述状态，而这算法采用是的位来描述，运算速度可以大大提升，以后写程序对于描述状态的变量大家可以借鉴这个例子，会让你的程序跑得更快　　　　　　　　　　　　　　　　　　　　　　　　
  //   ２、描述每行可放置的位置都是只用row,ld,rd这３个变量来描述，这样使得程序看起来挺简洁的。